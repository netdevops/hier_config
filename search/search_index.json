{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Welcome to the Hierarchical Configuration documentation site. Hierarchical Configuration, also known as hier_config , is a python library is able to take a running configuration of a network device, compare it to its intended configuration, and build the remediation steps necessary to bring a device into spec with its intended configuration. Hierarchical Configuraiton has been used extensively on: [x] Cisco IOS [x] Cisco IOSXR [x] Cisco NXOS [x] Arista EOS However, any NOS that utilizes a CLI syntax that is structured in a similar fasion to IOS should work mostly out of the box.","title":"Home"},{"location":"#introduction","text":"Welcome to the Hierarchical Configuration documentation site. Hierarchical Configuration, also known as hier_config , is a python library is able to take a running configuration of a network device, compare it to its intended configuration, and build the remediation steps necessary to bring a device into spec with its intended configuration. Hierarchical Configuraiton has been used extensively on: [x] Cisco IOS [x] Cisco IOSXR [x] Cisco NXOS [x] Arista EOS However, any NOS that utilizes a CLI syntax that is structured in a similar fasion to IOS should work mostly out of the box.","title":"Introduction"},{"location":"advanced-topics/","text":"Advanced Topics Lineage Rules Lineage rules are rules that are written in YAML. They allow users to seek out very specific sections of configurations or even seek out very generalized lines within a configuration. For example, suppose you just wanted to seek out interface descriptions. Your lineage rule would look like: - lineage: - startswith: interface - startswith: description In the above example, a start of a lineage is defined with the - lineage: syntax. From there the interface is defined with the - startswith: interface syntax under the - lineage: umbrella. This tells hier_config to search for any configuration that starts with the string interface as the parent of a configuration line. When it finds an interface parent, it then looks at any child configuration line of the interface that starts with the string description . With lineage rules, you can get as deep into the children or as shallow as you need. Suppose you want to inspect the existence or absence of http, ssh, snmp, and logging within a configuration. This can be done with a single lineage rule, like so: - lineage: - startswith: - ip ssh - no ip ssh - ip http - no ip http - snmp-server - no snmp-server - logging - no logging Or suppose, you want to inspect whether BGP IPv4 AFIs are activated. You can do this with the following: - lineage: - startswith: router bgp - startswith: address-family ipv4 - endswith: activate In the above example, I utilized a different keyword to look for activated BGP neighbors. The keywords that can be utilized within lineage rules are: - startswith - endswith - contains - equals - re_search You can also put all of the above examples together in the same set of lineage rules like so: - lineage: - startswith: interface - startswith: description - lineage: - startswith: - ip ssh - no ip ssh - ip http - no ip http - snmp-server - no snmp-server - logging - no logging - lineage: - startswith: router bgp - startswith: address-family ipv4 - endswith: activate When hier_config consumes the lineage rules, it consumes them as a list of lineage rules and processes them individually. Working with Tags With a firm understanding of lineage rules, more complex use cases become available within hier_config. A powerful use case is the ability to tag specific sections of configuration and only display remediations based on those tags. This becomes very handy when you're attempting to execute a maintenance that only targets low risk configuration changes or isolate the more risky configuration changes to scrutinize their execution during a maintenance. Tagging expands on the use of the lineage rules by creating an add_tags keyword to a lineage rule. Suppose you had a running configuration that had an ntp configuration that looked like: ntp server 192.0.2.1 prefer version 2 However, your intended configuration utilized a publicly available NTP server on the internet: ip name-server 1.1.1.1 ip name-server 8.8.8.8 ntp server time.nist.gov You could create a lineage rule that targeted that specific remediation like this: - lineage: - startswith: - ip name-server - no ip name-server - ntp - no ntp add_tags: ntp Now we can modify the script above to load the tags and create a remediation of the said tags: #!/usr/bin/env python3 # Import the hier_config Host library from hier_config import Host # Create a hier_config Host object host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") # Load the tagged lineage rules host.load_tags_from_file(\"./tests/fixtures/tags_ios.yml\") # Load a running configuration from a file host.load_running_config_from_file(\"./tests/fixtures/running_config.conf\") # Load an intended configuration from a file host.load_generated_config_from_file(\"./tests/fixtures/generated_config.conf\") # Create the remediation steps host.remediation_config() # Display the remediation steps for only the \"ntp\" tags print(host.remediation_config_filtered_text(include_tags={\"ntp\"}, exclude_tags={})) In the script, we made two changes. The first change is to load the tagged lineage rules: host.load_tags_from_file(\"./tests/fixtures/tags_ios.yml\") . And the second is to filter the remediation steps by only including steps that are tagged with ntp via the include_tags argument. The remediation looks like: no ntp server 192.0.2.1 prefer version 2 ip name-server 1.1.1.1 ip name-server 8.8.8.8 ntp server time.nist.gov hier_config Options There are a number of options that can be loaded into hier_config to make it better conform to the nuances of your network device. By default, hier_config loads a set of sane defaults for Cisco IOS, IOS XE, IOS XR, NX-OS, and Arista EOS. Below are the configuration options available for manipulation. base_options: dict = { \"style\": None, \"sectional_overwrite\": [], \"sectional_overwrite_no_negate\": [], \"ordering\": [], \"indent_adjust\": [], \"parent_allows_duplicate_child\": [], \"sectional_exiting\": [], \"full_text_sub\": [], \"per_line_sub\": [], \"idempotent_commands_blacklist\": [], \"idempotent_commands\": [], \"negation_default_when\": [], \"negation_negate_with\": [], } The default options can be completely overwritten and loaded from a yaml file, or individual components of the options can be manipulated to provide the functionality that is desired. Here is an example of manipulating the built-in options. # Import the hier_config Host library from hier_config import Host # Create a hier_config Host object host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") # Create an NTP negation ordered lineage rule ordered_negate_ntp = {\"lineage\": [{\"startswith\": [\"no ntp\"], \"order\": 700}]} # Update the hier_config options \"ordering\" key. host.hconfig_options[\"ordering\"].append(ordered_negate_ntp) Here is an example of completely overwriting the default options and loading in your own. # import YAML import yaml # Import the hier_config Host library from hier_config import Host # Load the hier_config options into memory with open(\"./tests/fixtures/options_ios.yml\") as f: options = yaml.load(f.read(), Loader=yaml.SafeLoader) # Create a hier_config Host object host = Host(hostame=\"aggr-example.rtr\", os=\"ios\", hconfig_options=options) In the following sections, I'll cover the available options. style The style defines the os family. Such as ios , iosxr , etc. Example: style: ios sectional_overwrite_no_negate The sectional overwrite with no negate hier_config option will completely overwrite sections of configuration without negating them. This option is often used with the RPL sections of IOS XR devices that require that the entire RPL be re-created when making modifications to them, rather than editing individual lines within the RPL. An example of sectional overwrite with no negate is: sectional_overwrite_no_negate: - lineage: - startswith: as-path-set - lineage: - startswith: prefix-set - lineage: - startswith: route-policy - lineage: - startswith: extcommunity-set - lineage: - startswith: community-set sectional_overwrite Sectional overwrite is just like sectional overwrite with no negate, except that hier_config will negate a section of configuration and then completely re-create it. ordering Ordering is one of the most useful hier_config options. This allows you to use lineage rules to define the order in which remediation steps are presented to the user. For the ntp example above, the ntp server was negated ( no ntp server 192.0.2.1 ) before the new ntp server was added. In most cases, this wouldn't be advantageous. Thus, ordering can be used to define the proper order to execute commands. All commands are assigned a default order weight of 500, with a usable order weight of 1 - 999. The smaller the weight value, the higher on the list of steps a command is to be executed. The larger the weight value, the lower on the list of steps a command is to be executed. To create an order in which new ntp servers are added before old ntp servers are removed, you can create an order lineage that weights the negation to the bottom. Example: ordering: - lineage: - startswith: no ntp order: 700 With the above order lineage applied, the output of the above ntp example would look like: ip name-server 1.1.1.1 ip name-server 8.8.8.8 ntp server time.nist.gov no ntp server 192.0.2.1 prefer version 2 indent_adjust coming soon... parent_allows_duplicate_child coming soon... sectional_exiting Sectional exiting features configuration sections that have a configuration syntax that defines the end of a configuration section. Examples of this are RPL (route policy language) configurations in IOS XR or peer policy and peer session configurations in IOS BGP sections. The sectional exiting configuration allows you to define the configuration syntax so that hier_config can render a remediation that properly exits those configurations. An example of sectional exiting is: sectional_exiting: - lineage: - startswith: router bgp - startswith: template peer-policy exit_text: exit-peer-policy - lineage: - startswith: router bgp - startswith: template peer-session exit_text: exit-peer-session full_text_sub Full text sub allows for substitutions of a multi-line string. Regular expressions are commonly used and allowed in this section. An example of this would be: full_text_sub: - search: \"banner\\s(exec|motd)\\s(\\S)\\n(.*\\n){1,}(\\2)\" replace: \"\" This example simply searches for a banner message in the configuration and replaces it with an empty string. per_line_sub Per line sub allows for substitutions of individual lines. This is commonly used to remove artifacts from a running configuration that don't provide any value when creating remediation steps. An example is removing lines such as: Building configuration... Current configuration : 3781 bytes Per line sub can be used to remove those lines: per_line_sub: - search: \"Building configuration.*\" replace: \"\" - search: \"Current configuration.*\" replace: \"\" idempotent_commands_blacklist coming soon... idempotent_commands Idempotent commands are commands that can just be overwritten and don't need negation. Lineage rules can be created to define those commands that are idempotent. An example of idempotent commands are: idempotent_commands: - lineage: - startswith: vlan - startswith: name - lineage: - startswith: interface - startswith: description The lineage rules above specify that defining a vlan name and updating an interface description are both idempotent commands. negation_default_when coming soon... negation_default_with coming soon... Custom hier_config Workflows Coming soon...","title":"Advanced Topics"},{"location":"advanced-topics/#advanced-topics","text":"","title":"Advanced Topics"},{"location":"advanced-topics/#lineage-rules","text":"Lineage rules are rules that are written in YAML. They allow users to seek out very specific sections of configurations or even seek out very generalized lines within a configuration. For example, suppose you just wanted to seek out interface descriptions. Your lineage rule would look like: - lineage: - startswith: interface - startswith: description In the above example, a start of a lineage is defined with the - lineage: syntax. From there the interface is defined with the - startswith: interface syntax under the - lineage: umbrella. This tells hier_config to search for any configuration that starts with the string interface as the parent of a configuration line. When it finds an interface parent, it then looks at any child configuration line of the interface that starts with the string description . With lineage rules, you can get as deep into the children or as shallow as you need. Suppose you want to inspect the existence or absence of http, ssh, snmp, and logging within a configuration. This can be done with a single lineage rule, like so: - lineage: - startswith: - ip ssh - no ip ssh - ip http - no ip http - snmp-server - no snmp-server - logging - no logging Or suppose, you want to inspect whether BGP IPv4 AFIs are activated. You can do this with the following: - lineage: - startswith: router bgp - startswith: address-family ipv4 - endswith: activate In the above example, I utilized a different keyword to look for activated BGP neighbors. The keywords that can be utilized within lineage rules are: - startswith - endswith - contains - equals - re_search You can also put all of the above examples together in the same set of lineage rules like so: - lineage: - startswith: interface - startswith: description - lineage: - startswith: - ip ssh - no ip ssh - ip http - no ip http - snmp-server - no snmp-server - logging - no logging - lineage: - startswith: router bgp - startswith: address-family ipv4 - endswith: activate When hier_config consumes the lineage rules, it consumes them as a list of lineage rules and processes them individually.","title":"Lineage Rules"},{"location":"advanced-topics/#working-with-tags","text":"With a firm understanding of lineage rules, more complex use cases become available within hier_config. A powerful use case is the ability to tag specific sections of configuration and only display remediations based on those tags. This becomes very handy when you're attempting to execute a maintenance that only targets low risk configuration changes or isolate the more risky configuration changes to scrutinize their execution during a maintenance. Tagging expands on the use of the lineage rules by creating an add_tags keyword to a lineage rule. Suppose you had a running configuration that had an ntp configuration that looked like: ntp server 192.0.2.1 prefer version 2 However, your intended configuration utilized a publicly available NTP server on the internet: ip name-server 1.1.1.1 ip name-server 8.8.8.8 ntp server time.nist.gov You could create a lineage rule that targeted that specific remediation like this: - lineage: - startswith: - ip name-server - no ip name-server - ntp - no ntp add_tags: ntp Now we can modify the script above to load the tags and create a remediation of the said tags: #!/usr/bin/env python3 # Import the hier_config Host library from hier_config import Host # Create a hier_config Host object host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") # Load the tagged lineage rules host.load_tags_from_file(\"./tests/fixtures/tags_ios.yml\") # Load a running configuration from a file host.load_running_config_from_file(\"./tests/fixtures/running_config.conf\") # Load an intended configuration from a file host.load_generated_config_from_file(\"./tests/fixtures/generated_config.conf\") # Create the remediation steps host.remediation_config() # Display the remediation steps for only the \"ntp\" tags print(host.remediation_config_filtered_text(include_tags={\"ntp\"}, exclude_tags={})) In the script, we made two changes. The first change is to load the tagged lineage rules: host.load_tags_from_file(\"./tests/fixtures/tags_ios.yml\") . And the second is to filter the remediation steps by only including steps that are tagged with ntp via the include_tags argument. The remediation looks like: no ntp server 192.0.2.1 prefer version 2 ip name-server 1.1.1.1 ip name-server 8.8.8.8 ntp server time.nist.gov","title":"Working with Tags"},{"location":"advanced-topics/#hier_config-options","text":"There are a number of options that can be loaded into hier_config to make it better conform to the nuances of your network device. By default, hier_config loads a set of sane defaults for Cisco IOS, IOS XE, IOS XR, NX-OS, and Arista EOS. Below are the configuration options available for manipulation. base_options: dict = { \"style\": None, \"sectional_overwrite\": [], \"sectional_overwrite_no_negate\": [], \"ordering\": [], \"indent_adjust\": [], \"parent_allows_duplicate_child\": [], \"sectional_exiting\": [], \"full_text_sub\": [], \"per_line_sub\": [], \"idempotent_commands_blacklist\": [], \"idempotent_commands\": [], \"negation_default_when\": [], \"negation_negate_with\": [], } The default options can be completely overwritten and loaded from a yaml file, or individual components of the options can be manipulated to provide the functionality that is desired. Here is an example of manipulating the built-in options. # Import the hier_config Host library from hier_config import Host # Create a hier_config Host object host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") # Create an NTP negation ordered lineage rule ordered_negate_ntp = {\"lineage\": [{\"startswith\": [\"no ntp\"], \"order\": 700}]} # Update the hier_config options \"ordering\" key. host.hconfig_options[\"ordering\"].append(ordered_negate_ntp) Here is an example of completely overwriting the default options and loading in your own. # import YAML import yaml # Import the hier_config Host library from hier_config import Host # Load the hier_config options into memory with open(\"./tests/fixtures/options_ios.yml\") as f: options = yaml.load(f.read(), Loader=yaml.SafeLoader) # Create a hier_config Host object host = Host(hostame=\"aggr-example.rtr\", os=\"ios\", hconfig_options=options) In the following sections, I'll cover the available options.","title":"hier_config Options"},{"location":"advanced-topics/#style","text":"The style defines the os family. Such as ios , iosxr , etc. Example: style: ios","title":"style"},{"location":"advanced-topics/#sectional_overwrite_no_negate","text":"The sectional overwrite with no negate hier_config option will completely overwrite sections of configuration without negating them. This option is often used with the RPL sections of IOS XR devices that require that the entire RPL be re-created when making modifications to them, rather than editing individual lines within the RPL. An example of sectional overwrite with no negate is: sectional_overwrite_no_negate: - lineage: - startswith: as-path-set - lineage: - startswith: prefix-set - lineage: - startswith: route-policy - lineage: - startswith: extcommunity-set - lineage: - startswith: community-set","title":"sectional_overwrite_no_negate"},{"location":"advanced-topics/#sectional_overwrite","text":"Sectional overwrite is just like sectional overwrite with no negate, except that hier_config will negate a section of configuration and then completely re-create it.","title":"sectional_overwrite"},{"location":"advanced-topics/#ordering","text":"Ordering is one of the most useful hier_config options. This allows you to use lineage rules to define the order in which remediation steps are presented to the user. For the ntp example above, the ntp server was negated ( no ntp server 192.0.2.1 ) before the new ntp server was added. In most cases, this wouldn't be advantageous. Thus, ordering can be used to define the proper order to execute commands. All commands are assigned a default order weight of 500, with a usable order weight of 1 - 999. The smaller the weight value, the higher on the list of steps a command is to be executed. The larger the weight value, the lower on the list of steps a command is to be executed. To create an order in which new ntp servers are added before old ntp servers are removed, you can create an order lineage that weights the negation to the bottom. Example: ordering: - lineage: - startswith: no ntp order: 700 With the above order lineage applied, the output of the above ntp example would look like: ip name-server 1.1.1.1 ip name-server 8.8.8.8 ntp server time.nist.gov no ntp server 192.0.2.1 prefer version 2","title":"ordering"},{"location":"advanced-topics/#indent_adjust","text":"coming soon...","title":"indent_adjust"},{"location":"advanced-topics/#parent_allows_duplicate_child","text":"coming soon...","title":"parent_allows_duplicate_child"},{"location":"advanced-topics/#sectional_exiting","text":"Sectional exiting features configuration sections that have a configuration syntax that defines the end of a configuration section. Examples of this are RPL (route policy language) configurations in IOS XR or peer policy and peer session configurations in IOS BGP sections. The sectional exiting configuration allows you to define the configuration syntax so that hier_config can render a remediation that properly exits those configurations. An example of sectional exiting is: sectional_exiting: - lineage: - startswith: router bgp - startswith: template peer-policy exit_text: exit-peer-policy - lineage: - startswith: router bgp - startswith: template peer-session exit_text: exit-peer-session","title":"sectional_exiting"},{"location":"advanced-topics/#full_text_sub","text":"Full text sub allows for substitutions of a multi-line string. Regular expressions are commonly used and allowed in this section. An example of this would be: full_text_sub: - search: \"banner\\s(exec|motd)\\s(\\S)\\n(.*\\n){1,}(\\2)\" replace: \"\" This example simply searches for a banner message in the configuration and replaces it with an empty string.","title":"full_text_sub"},{"location":"advanced-topics/#per_line_sub","text":"Per line sub allows for substitutions of individual lines. This is commonly used to remove artifacts from a running configuration that don't provide any value when creating remediation steps. An example is removing lines such as: Building configuration... Current configuration : 3781 bytes Per line sub can be used to remove those lines: per_line_sub: - search: \"Building configuration.*\" replace: \"\" - search: \"Current configuration.*\" replace: \"\"","title":"per_line_sub"},{"location":"advanced-topics/#idempotent_commands_blacklist","text":"coming soon...","title":"idempotent_commands_blacklist"},{"location":"advanced-topics/#idempotent_commands","text":"Idempotent commands are commands that can just be overwritten and don't need negation. Lineage rules can be created to define those commands that are idempotent. An example of idempotent commands are: idempotent_commands: - lineage: - startswith: vlan - startswith: name - lineage: - startswith: interface - startswith: description The lineage rules above specify that defining a vlan name and updating an interface description are both idempotent commands.","title":"idempotent_commands"},{"location":"advanced-topics/#negation_default_when","text":"coming soon...","title":"negation_default_when"},{"location":"advanced-topics/#negation_default_with","text":"coming soon...","title":"negation_default_with"},{"location":"advanced-topics/#custom-hier_config-workflows","text":"Coming soon...","title":"Custom hier_config Workflows"},{"location":"experimental-features/","text":"Experimental Features Experimental features are those features that work, but haven't been thoroughly tested enough to feel confident to use in production. Rollback Configuration Starting in version 2.0.2, a featured called rollback configuraiton was introduced. The rollback configuration is exactly what it sounds like. It renders a rollback configuration in the event that a remediation causes a hiccup when being deployed. The rollback configuration does the inverse on a remediation. Instead of a remediation being renedered based upon the generated config, a rollback remediation is rendered from the generated config based upon the running configuration. A rollback configuration can be rendered once the running and generated configurations are loaded. Below is an example. >>> from hier_config import Host >>> host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") >>> host.load_running_config_from_file(\"./tests/fixtures/running_config.conf\") >>> host.load_generated_config_from_file(\"./tests/fixtures/generated_config.conf\") >>> rollback = host.rollback_config() >>> for line in rollback.all_children_sorted(): ... print(line.cisco_style_text()) ... no vlan 4 no interface Vlan4 vlan 3 name switch_mgmt_10.0.4.0/24 interface Vlan2 no mtu 9000 no ip access-group TEST in shutdown interface Vlan3 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 >>> Unified diff Starting in version 2.1.0, a featured called unified diff was introduced. It provides a similar output to difflib.unified_diff() but is aware of out of order lines and the parent child relationships present in the hier_config model of the configurations being diffed. This feature is useful in cases where you need to compare the differences of two network device configurations. Such as comparing the configs of redundant device pairs. Or, comparing running and intended configs. In its current state, this algorithm does not consider duplicate child differences. e.g. two instances endif in an IOS-XR route-policy. It also does not respect the order of commands where it may count, such as in ACLs. In the case of ACLs, they should contain sequence numbers if order is important. In [1]: list(running_config.unified_diff(generated_config)) Out[1]: ['vlan 3', ' - name switch_mgmt_10.0.4.0/24', ' + name switch_mgmt_10.0.3.0/24', 'interface Vlan2', ' - shutdown', ' + mtu 9000', ' + ip access-group TEST in', ' + no shutdown', 'interface Vlan3', ' - description switch_mgmt_10.0.4.0/24', ' - ip address 10.0.4.1 255.255.0.0', ' + description switch_mgmt_10.0.3.0/24', ' + ip address 10.0.3.1 255.255.0.0', '+ vlan 4', ' + name switch_mgmt_10.0.4.0/24', '+ interface Vlan4', ' + mtu 9000', ' + description switch_mgmt_10.0.4.0/24', ' + ip address 10.0.4.1 255.255.0.0', ' + ip access-group TEST in', ' + no shutdown'] Future Config Starting in version 2.2.0, a featured called future config was introduced. It attempts to predict the running config after a change is applied. This feature is useful in cases where you need to determine what the configuration state will be after a change is applied. Such as: - Ensuring that a configuration change was applied successfully to a device. - i.e. Does the post-change config match the predicted future config? - Providing a future state config that can be fed into batfish, or similar, to predict if a change will cause an impact. - Building rollback configs. If you have the future config state, then generating a rollback config can be done by simply building the remediation config in the reverse direction rollback = future.config_to_get_to(running) . - If you are building rollbacks for a series of config changes, you can feed the post-change-1 future config into the process for determining the post-change-2 future config e.g. shell post_change_1_config = running_config.future(change_1_config) change_1_rollback_config = post_change_1_config.config_to_get_to(running_config) post_change_2_config = post_change_1_config.future(change_2_config) change_2_rollback_config = post_change_2_config.config_to_get_to(post_change_1_config) ... In its current state, this algorithm does not consider: - negate a numbered ACL when removing an item - sectional exiting - negate with - idempotent command blacklist - idempotent_acl_check - and likely others In [1]: from hier_config import HConfig, Host ...: ...: ...: host = Host(\"test.dfw1\", \"ios\") ...: running_config = HConfig(host) ...: running_config.load_from_file(\"./tests/fixtures/running_config.conf\") ...: remediation_config = HConfig(host) ...: remediation_config.load_from_file(\"./tests/fixtures/remediation_config_without_tags.conf\") ...: future_config = running_config.future(remediation_config) ...: ...: print(\"\\n##### running config\") ...: for line in running_config.all_children(): ...: print(line.cisco_style_text()) ...: ...: print(\"\\n##### remediation config\") ...: for line in remediation_config.all_children(): ...: print(line.cisco_style_text()) ...: ...: print(\"\\n##### future config\") ...: for line in future_config.all_children(): ...: print(line.cisco_style_text()) ...: ##### running config hostname aggr-example.rtr ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any vlan 2 name switch_mgmt_10.0.2.0/24 vlan 3 name switch_mgmt_10.0.4.0/24 interface Vlan2 descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 shutdown interface Vlan3 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown ##### remediation config vlan 3 name switch_mgmt_10.0.3.0/24 vlan 4 name switch_mgmt_10.0.4.0/24 interface Vlan2 mtu 9000 ip access-group TEST in no shutdown interface Vlan3 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown ##### future config vlan 3 name switch_mgmt_10.0.3.0/24 vlan 4 name switch_mgmt_10.0.4.0/24 interface Vlan2 mtu 9000 ip access-group TEST in descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 interface Vlan3 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 mtu 9000 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown hostname aggr-example.rtr ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any vlan 2 name switch_mgmt_10.0.2.0/24","title":"Experimental Features"},{"location":"experimental-features/#experimental-features","text":"Experimental features are those features that work, but haven't been thoroughly tested enough to feel confident to use in production.","title":"Experimental Features"},{"location":"experimental-features/#rollback-configuration","text":"Starting in version 2.0.2, a featured called rollback configuraiton was introduced. The rollback configuration is exactly what it sounds like. It renders a rollback configuration in the event that a remediation causes a hiccup when being deployed. The rollback configuration does the inverse on a remediation. Instead of a remediation being renedered based upon the generated config, a rollback remediation is rendered from the generated config based upon the running configuration. A rollback configuration can be rendered once the running and generated configurations are loaded. Below is an example. >>> from hier_config import Host >>> host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") >>> host.load_running_config_from_file(\"./tests/fixtures/running_config.conf\") >>> host.load_generated_config_from_file(\"./tests/fixtures/generated_config.conf\") >>> rollback = host.rollback_config() >>> for line in rollback.all_children_sorted(): ... print(line.cisco_style_text()) ... no vlan 4 no interface Vlan4 vlan 3 name switch_mgmt_10.0.4.0/24 interface Vlan2 no mtu 9000 no ip access-group TEST in shutdown interface Vlan3 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 >>>","title":"Rollback Configuration"},{"location":"experimental-features/#unified-diff","text":"Starting in version 2.1.0, a featured called unified diff was introduced. It provides a similar output to difflib.unified_diff() but is aware of out of order lines and the parent child relationships present in the hier_config model of the configurations being diffed. This feature is useful in cases where you need to compare the differences of two network device configurations. Such as comparing the configs of redundant device pairs. Or, comparing running and intended configs. In its current state, this algorithm does not consider duplicate child differences. e.g. two instances endif in an IOS-XR route-policy. It also does not respect the order of commands where it may count, such as in ACLs. In the case of ACLs, they should contain sequence numbers if order is important. In [1]: list(running_config.unified_diff(generated_config)) Out[1]: ['vlan 3', ' - name switch_mgmt_10.0.4.0/24', ' + name switch_mgmt_10.0.3.0/24', 'interface Vlan2', ' - shutdown', ' + mtu 9000', ' + ip access-group TEST in', ' + no shutdown', 'interface Vlan3', ' - description switch_mgmt_10.0.4.0/24', ' - ip address 10.0.4.1 255.255.0.0', ' + description switch_mgmt_10.0.3.0/24', ' + ip address 10.0.3.1 255.255.0.0', '+ vlan 4', ' + name switch_mgmt_10.0.4.0/24', '+ interface Vlan4', ' + mtu 9000', ' + description switch_mgmt_10.0.4.0/24', ' + ip address 10.0.4.1 255.255.0.0', ' + ip access-group TEST in', ' + no shutdown']","title":"Unified diff"},{"location":"experimental-features/#future-config","text":"Starting in version 2.2.0, a featured called future config was introduced. It attempts to predict the running config after a change is applied. This feature is useful in cases where you need to determine what the configuration state will be after a change is applied. Such as: - Ensuring that a configuration change was applied successfully to a device. - i.e. Does the post-change config match the predicted future config? - Providing a future state config that can be fed into batfish, or similar, to predict if a change will cause an impact. - Building rollback configs. If you have the future config state, then generating a rollback config can be done by simply building the remediation config in the reverse direction rollback = future.config_to_get_to(running) . - If you are building rollbacks for a series of config changes, you can feed the post-change-1 future config into the process for determining the post-change-2 future config e.g. shell post_change_1_config = running_config.future(change_1_config) change_1_rollback_config = post_change_1_config.config_to_get_to(running_config) post_change_2_config = post_change_1_config.future(change_2_config) change_2_rollback_config = post_change_2_config.config_to_get_to(post_change_1_config) ... In its current state, this algorithm does not consider: - negate a numbered ACL when removing an item - sectional exiting - negate with - idempotent command blacklist - idempotent_acl_check - and likely others In [1]: from hier_config import HConfig, Host ...: ...: ...: host = Host(\"test.dfw1\", \"ios\") ...: running_config = HConfig(host) ...: running_config.load_from_file(\"./tests/fixtures/running_config.conf\") ...: remediation_config = HConfig(host) ...: remediation_config.load_from_file(\"./tests/fixtures/remediation_config_without_tags.conf\") ...: future_config = running_config.future(remediation_config) ...: ...: print(\"\\n##### running config\") ...: for line in running_config.all_children(): ...: print(line.cisco_style_text()) ...: ...: print(\"\\n##### remediation config\") ...: for line in remediation_config.all_children(): ...: print(line.cisco_style_text()) ...: ...: print(\"\\n##### future config\") ...: for line in future_config.all_children(): ...: print(line.cisco_style_text()) ...: ##### running config hostname aggr-example.rtr ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any vlan 2 name switch_mgmt_10.0.2.0/24 vlan 3 name switch_mgmt_10.0.4.0/24 interface Vlan2 descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 shutdown interface Vlan3 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown ##### remediation config vlan 3 name switch_mgmt_10.0.3.0/24 vlan 4 name switch_mgmt_10.0.4.0/24 interface Vlan2 mtu 9000 ip access-group TEST in no shutdown interface Vlan3 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown ##### future config vlan 3 name switch_mgmt_10.0.3.0/24 vlan 4 name switch_mgmt_10.0.4.0/24 interface Vlan2 mtu 9000 ip access-group TEST in descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 interface Vlan3 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 mtu 9000 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown hostname aggr-example.rtr ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any vlan 2 name switch_mgmt_10.0.2.0/24","title":"Future Config"},{"location":"getting-started/","text":"hier_config Up and Running Hierarchical Configuration doesn't communicate with devices themselves. It simply reads configuration data and creates a remediation plan based on the input from a running config and the input from a generated config. The very first thing that needs to happen is that a hier_config Host object needs to be initiated for a device. To do this, import the hier_config Host class. from hier_config import Host With the Host class imported, it can be utilized to create host objects. host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") Once a host object has been created, the running configuration and generated configurations of a network device can be loaded into the host object. These configurations can be loaded in two ways. If you already have the configurations loaded as strings in memory, you can load them from the strings. Example of loading configs from in memory strings : running_config = \"\"\"hostname aggr-example.rtr ! ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any ! vlan 2 name switch_mgmt_10.0.2.0/24 ! vlan 3 name switch_mgmt_10.0.4.0/24 ! interface Vlan2 descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 shutdown ! interface Vlan3 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown\"\"\" generated_config = \"\"\"hostname aggr-example.rtr ! ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any ! vlan 2 name switch_mgmt_10.0.2.0/24 ! vlan 3 name switch_mgmt_10.0.3.0/24 ! vlan 4 name switch_mgmt_10.0.4.0/24 ! interface Vlan2 mtu 9000 descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 ip access-group TEST in no shutdown ! interface Vlan3 mtu 9000 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 ip access-group TEST in no shutdown ! interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown\"\"\" host.load_running_config(config_text=running_config) host.load_generated_config(config_text=generated_config) The second method for loading configs into the host object is loading the configs from files. Example of loading configs from files. host.load_running_config_from_file(\"./tests/fixtures/running_config.conf\") host.load_generated_config_from_file(\"./tests/fixtures/generated_config.conf\") Once the configs are loaded into the host object, a remediation can be created. host.remediation_config() host.remediation_config() is loaded as a python object. To view the results of the remediation, call the host.remediation_config_filtered_text(include_tags={}, exclude_tags={}) method. print(host.remediation_config_filtered_text(include_tags={}, exclude_tags={})) If you're using the examples from the /tests/fixtures folder in the github repository, you should see an output that resembles: vlan 3 name switch_mgmt_10.0.3.0/24 vlan 4 name switch_mgmt_10.0.4.0/24 interface Vlan2 mtu 9000 ip access-group TEST in no shutdown interface Vlan3 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown","title":"Getting Started"},{"location":"getting-started/#hier_config-up-and-running","text":"Hierarchical Configuration doesn't communicate with devices themselves. It simply reads configuration data and creates a remediation plan based on the input from a running config and the input from a generated config. The very first thing that needs to happen is that a hier_config Host object needs to be initiated for a device. To do this, import the hier_config Host class. from hier_config import Host With the Host class imported, it can be utilized to create host objects. host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") Once a host object has been created, the running configuration and generated configurations of a network device can be loaded into the host object. These configurations can be loaded in two ways. If you already have the configurations loaded as strings in memory, you can load them from the strings. Example of loading configs from in memory strings : running_config = \"\"\"hostname aggr-example.rtr ! ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any ! vlan 2 name switch_mgmt_10.0.2.0/24 ! vlan 3 name switch_mgmt_10.0.4.0/24 ! interface Vlan2 descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 shutdown ! interface Vlan3 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown\"\"\" generated_config = \"\"\"hostname aggr-example.rtr ! ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any ! vlan 2 name switch_mgmt_10.0.2.0/24 ! vlan 3 name switch_mgmt_10.0.3.0/24 ! vlan 4 name switch_mgmt_10.0.4.0/24 ! interface Vlan2 mtu 9000 descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 ip access-group TEST in no shutdown ! interface Vlan3 mtu 9000 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 ip access-group TEST in no shutdown ! interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown\"\"\" host.load_running_config(config_text=running_config) host.load_generated_config(config_text=generated_config) The second method for loading configs into the host object is loading the configs from files. Example of loading configs from files. host.load_running_config_from_file(\"./tests/fixtures/running_config.conf\") host.load_generated_config_from_file(\"./tests/fixtures/generated_config.conf\") Once the configs are loaded into the host object, a remediation can be created. host.remediation_config() host.remediation_config() is loaded as a python object. To view the results of the remediation, call the host.remediation_config_filtered_text(include_tags={}, exclude_tags={}) method. print(host.remediation_config_filtered_text(include_tags={}, exclude_tags={})) If you're using the examples from the /tests/fixtures folder in the github repository, you should see an output that resembles: vlan 3 name switch_mgmt_10.0.3.0/24 vlan 4 name switch_mgmt_10.0.4.0/24 interface Vlan2 mtu 9000 ip access-group TEST in no shutdown interface Vlan3 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown","title":"hier_config Up and Running"},{"location":"install/","text":"Install hier_config Hierarchical Configuration requires a minimum Python version of 3.8. Hierarchical Configuration can be installed directly from github or with pip: Github Install Poetry Clone the Repository: git clone git@github.com:netdevops/hier_config.git Install hier_config: cd hier_config && poetry install Pip Install from PyPI : pip install hier-config","title":"Install"},{"location":"install/#install-hier_config","text":"Hierarchical Configuration requires a minimum Python version of 3.8. Hierarchical Configuration can be installed directly from github or with pip:","title":"Install hier_config"},{"location":"install/#github","text":"Install Poetry Clone the Repository: git clone git@github.com:netdevops/hier_config.git Install hier_config: cd hier_config && poetry install","title":"Github"},{"location":"install/#pip","text":"Install from PyPI : pip install hier-config","title":"Pip"}]}