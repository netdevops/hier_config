{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Welcome to the Hierarchical Configuration documentation site. Hierarchical Configuration, also known as hier_config , is a python library is able to take a running configuration of a network device, compare it to its intended configuration, and build the remediation steps necessary to bring a device into spec with its intended configuration. Hierarchical Configuraiton has been used extensively on: [x] Cisco IOS [x] Cisco IOSXR [x] Cisco NXOS [x] Arista EOS However, any NOS that utilizes a CLI syntax that is structured in a similar fasion to IOS should work mostly out of the box.","title":"Home"},{"location":"#introduction","text":"Welcome to the Hierarchical Configuration documentation site. Hierarchical Configuration, also known as hier_config , is a python library is able to take a running configuration of a network device, compare it to its intended configuration, and build the remediation steps necessary to bring a device into spec with its intended configuration. Hierarchical Configuraiton has been used extensively on: [x] Cisco IOS [x] Cisco IOSXR [x] Cisco NXOS [x] Arista EOS However, any NOS that utilizes a CLI syntax that is structured in a similar fasion to IOS should work mostly out of the box.","title":"Introduction"},{"location":"advanced-topics/","text":"Advanced Topics Lineage Rules Coming soon... Working with Tags Coming soon... hier_config Options Coming soon... Custom hier_config Workflows Coming soon...","title":"Advanced Topics"},{"location":"advanced-topics/#advanced-topics","text":"","title":"Advanced Topics"},{"location":"advanced-topics/#lineage-rules","text":"Coming soon...","title":"Lineage Rules"},{"location":"advanced-topics/#working-with-tags","text":"Coming soon...","title":"Working with Tags"},{"location":"advanced-topics/#hier_config-options","text":"Coming soon...","title":"hier_config Options"},{"location":"advanced-topics/#custom-hier_config-workflows","text":"Coming soon...","title":"Custom hier_config Workflows"},{"location":"experimental-features/","text":"Experimental Features Experimental features are those features that work, but haven't been thoroughly tested enough to feel confident to use in production. Rollback Configuration Starting in version 2.0.2, a featured called rollback configuraiton was introduced. The rollback configuration is exactly what it sounds like. It renders a rollback configuration in the event that a remediation causes a hiccup when being deployed. The rollback configuration does the inverse on a remediation. Instead of a remediation being renedered based upon the generated config, a rollback remediation is rendered from the generated config based upon the running configuration. A rollback configuration can be rendered once the running and generated configurations are loaded. Below is an example. >>> from hier_config import Host >>> host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") >>> host.load_running_config_from_file(\"./tests/fixtures/running_config.conf\") >>> host.load_generated_config_from_file(\"./tests/fixtures/generated_config.conf\") >>> rollback = host.rollback_config() >>> for line in rollback.all_children_sorted(): ... print(line.cisco_style_text()) ... no vlan 4 no interface Vlan4 vlan 3 name switch_mgmt_10.0.4.0/24 interface Vlan2 no mtu 9000 no ip access-group TEST in shutdown interface Vlan3 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 >>>","title":"Experimental Features"},{"location":"experimental-features/#experimental-features","text":"Experimental features are those features that work, but haven't been thoroughly tested enough to feel confident to use in production.","title":"Experimental Features"},{"location":"experimental-features/#rollback-configuration","text":"Starting in version 2.0.2, a featured called rollback configuraiton was introduced. The rollback configuration is exactly what it sounds like. It renders a rollback configuration in the event that a remediation causes a hiccup when being deployed. The rollback configuration does the inverse on a remediation. Instead of a remediation being renedered based upon the generated config, a rollback remediation is rendered from the generated config based upon the running configuration. A rollback configuration can be rendered once the running and generated configurations are loaded. Below is an example. >>> from hier_config import Host >>> host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") >>> host.load_running_config_from_file(\"./tests/fixtures/running_config.conf\") >>> host.load_generated_config_from_file(\"./tests/fixtures/generated_config.conf\") >>> rollback = host.rollback_config() >>> for line in rollback.all_children_sorted(): ... print(line.cisco_style_text()) ... no vlan 4 no interface Vlan4 vlan 3 name switch_mgmt_10.0.4.0/24 interface Vlan2 no mtu 9000 no ip access-group TEST in shutdown interface Vlan3 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 >>>","title":"Rollback Configuration"},{"location":"getting-started/","text":"hier_config Up and Running Hierarchical Configuration doesn't communicate with devices themselves. It simply reads configuration data and creates a remediation plan based on the input from a running config and the input from a generated config. The very first thing that needs to happen is that a hier_config Host object needs to be initiated for a device. To do this, import the hier_config Host class. from hier_config import Host With the Host class imported, it can be utilized to create host objects. host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") Once a host object has been created, the running configuration and generated configurations of a network device can be loaded into the host object. These configurations can be loaded in two ways. If you already have the configurations loaded as strings in memory, you can load them from the strings. Example of loading configs from in memory strings : running_config = \"\"\"hostname aggr-example.rtr ! ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any ! vlan 2 name switch_mgmt_10.0.2.0/24 ! vlan 3 name switch_mgmt_10.0.4.0/24 ! interface Vlan2 descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 shutdown ! interface Vlan3 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown\"\"\" generated_config = \"\"\"hostname aggr-example.rtr ! ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any ! vlan 2 name switch_mgmt_10.0.2.0/24 ! vlan 3 name switch_mgmt_10.0.3.0/24 ! vlan 4 name switch_mgmt_10.0.4.0/24 ! interface Vlan2 mtu 9000 descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 ip access-group TEST in no shutdown ! interface Vlan3 mtu 9000 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 ip access-group TEST in no shutdown ! interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown\"\"\" host.load_running_config(config_text=running_config) host.load_generated_config(config_text=generated_config) The second method for loading configs into the host object is loading the configs from files. Example of loading configs from files. host.load_running_config_from_file(\"./tests/fixtures/running_config.conf\") host.load_generated_config_from_file(\"./tests/fixtures/generated_config.conf\") Once the configs are loaded into the host object, a remediation can be created. host.remediation_config() host.remediation_config() is loaded as a python object. To view the results of the remediation, create a new variable from the remediation_config() object and iterate through the all_children() or all_children_sorted() function. remediation_config = host.remediation_config() for line in remediation_config.all_children_sorted(): print(line.cisco_style_text()) If you're using the examples from the /tests/fixtures folder in the github repository, you should see an output that resembles: vlan 3 name switch_mgmt_10.0.3.0/24 vlan 4 name switch_mgmt_10.0.4.0/24 interface Vlan2 mtu 9000 ip access-group TEST in no shutdown interface Vlan3 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown","title":"Getting Started"},{"location":"getting-started/#hier_config-up-and-running","text":"Hierarchical Configuration doesn't communicate with devices themselves. It simply reads configuration data and creates a remediation plan based on the input from a running config and the input from a generated config. The very first thing that needs to happen is that a hier_config Host object needs to be initiated for a device. To do this, import the hier_config Host class. from hier_config import Host With the Host class imported, it can be utilized to create host objects. host = Host(hostname=\"aggr-example.rtr\", os=\"ios\") Once a host object has been created, the running configuration and generated configurations of a network device can be loaded into the host object. These configurations can be loaded in two ways. If you already have the configurations loaded as strings in memory, you can load them from the strings. Example of loading configs from in memory strings : running_config = \"\"\"hostname aggr-example.rtr ! ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any ! vlan 2 name switch_mgmt_10.0.2.0/24 ! vlan 3 name switch_mgmt_10.0.4.0/24 ! interface Vlan2 descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 shutdown ! interface Vlan3 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown\"\"\" generated_config = \"\"\"hostname aggr-example.rtr ! ip access-list extended TEST 10 permit ip 10.0.0.0 0.0.0.7 any ! vlan 2 name switch_mgmt_10.0.2.0/24 ! vlan 3 name switch_mgmt_10.0.3.0/24 ! vlan 4 name switch_mgmt_10.0.4.0/24 ! interface Vlan2 mtu 9000 descripton switch_10.0.2.0/24 ip address 10.0.2.1 255.255.255.0 ip access-group TEST in no shutdown ! interface Vlan3 mtu 9000 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 ip access-group TEST in no shutdown ! interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown\"\"\" host.load_running_config(config_text=running_config) host.load_generated_config(config_text=generated_config) The second method for loading configs into the host object is loading the configs from files. Example of loading configs from files. host.load_running_config_from_file(\"./tests/fixtures/running_config.conf\") host.load_generated_config_from_file(\"./tests/fixtures/generated_config.conf\") Once the configs are loaded into the host object, a remediation can be created. host.remediation_config() host.remediation_config() is loaded as a python object. To view the results of the remediation, create a new variable from the remediation_config() object and iterate through the all_children() or all_children_sorted() function. remediation_config = host.remediation_config() for line in remediation_config.all_children_sorted(): print(line.cisco_style_text()) If you're using the examples from the /tests/fixtures folder in the github repository, you should see an output that resembles: vlan 3 name switch_mgmt_10.0.3.0/24 vlan 4 name switch_mgmt_10.0.4.0/24 interface Vlan2 mtu 9000 ip access-group TEST in no shutdown interface Vlan3 description switch_mgmt_10.0.3.0/24 ip address 10.0.3.1 255.255.0.0 interface Vlan4 mtu 9000 description switch_mgmt_10.0.4.0/24 ip address 10.0.4.1 255.255.0.0 ip access-group TEST in no shutdown","title":"hier_config Up and Running"},{"location":"install/","text":"Install hier_config Hierarchical Configuration can be installed directly from github or with pip: Github Install Poetry Clone the Repository: git clone git@github.com:netdevops/hier_config.git Install hier_config: cd hier_config; poetry install Pip Install from PyPi: pip install hier-config","title":"Install"},{"location":"install/#install-hier_config","text":"Hierarchical Configuration can be installed directly from github or with pip:","title":"Install hier_config"},{"location":"install/#github","text":"Install Poetry Clone the Repository: git clone git@github.com:netdevops/hier_config.git Install hier_config: cd hier_config; poetry install","title":"Github"},{"location":"install/#pip","text":"Install from PyPi: pip install hier-config","title":"Pip"}]}